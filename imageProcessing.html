<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Image Processing</title>

    <!-- Bootstrap Core CSS -->
    <link href="vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <!-- Theme CSS -->
    <link href="css/clean-blog.min.css" rel="stylesheet">

    <!-- Custom Fonts -->
    <link href="vendor/font-awesome/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

</head>

<body>

    <!-- Navigation -->
    <nav class="navbar navbar-default navbar-custom navbar-fixed-top">
        <div class="container-fluid">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header page-scroll">
                <!--<button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    Menu <i class="fa fa-bars"></i>
                </button>-->
                <a class="navbar-brand" href="index.html">Advanced Computer Graphics</a>
            </div>

            <!-- Collect the nav links, forms, and other content for toggling -->
            <!--<div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="index.html">Projects</a>
                    </li>
                    <li>
                        <a href="about.html">About</a>
                    </li>
                    <li>
                        <a href="post.html">Sample Post</a>
                    </li>
                    <li>
                        <a href="contact.html">Contact</a>
                    </li>
                </ul>
            </div>-->
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <!-- Page Header -->
    <!-- Set your background image for this header on the line below. -->
    <header class="intro-header" style="background-color: #373D49">
        <div class="container">
            <div class="row">
                <div class="col-lg-10 col-lg-offset-1 col-md-10 col-md-offset-1">
                    <div class="post-heading">
                        <h1>An Image Processing Tool</h1>
                        <h3>
                            Implemented some basic image processing operations in C++, such as those found in programs like <i>Photoshop</i> or <i>ImageMagick</i>. It includes basic things like brightening, gamma correcting and cropping, as well as more advanced operations like antialiased shifting and resizing.
                        </h3>
                        <span class="meta">Posted on April 08, 2017</span>
                    </div>
                </div>
            </div>
        </div>
    </header>

    <!-- Post Content -->
    <article>
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    <h2 class="section-heading">Software</h2>
                    <p>
                    Download Unix Executable:
                    </p>
                    <p>
                    <blockquote> 
                        Example Usage: 
                        <br>
                        <code>
                            $ ./image -help
                        </code>
                    </blockquote>
                    </p>

                    <h2 class="section-heading">Some Basics</h2>
                    <p>
                        Pixel is the basic unit of programmable color in a computer image. Each pixel is a sample of an original image. The intensity of each pixel is a variable. A pixel is typically represented by three or four component intensities such as red, green, and blue, which are typically in the range of 0 – 255, this is also known as the RGB color model.
                    <p>
                    <h2 class="section-heading">Changing Brightness</h2>
                    <p>
                        To adjust image brightness, we simply scale each RGB component of a pixel by a positive factor &alpha;, When &alpha; is 0, we get a pure black image, when &alpha; is 1 we get the original image back. In other words, if we want to darken the image, we interpolate between the zero RGB intensities (black image) and the current image. Note that linear interpolation is often used to blend two images by interpolating between between corresponding pixel values of the two images as in the following example, where &alpha; and (1 - &alpha;) are used in a weighted average to obtain the interpolated pixel values:
                        <blockquote class="equation">
                            output_rgb_component = (1 - &alpha;) * black_rgb_component + &alpha; * input_rgb_component
                        </blockquote>
                    </p>
                    <p>
                        Since black RGB component is 0, we can simplify the formula: 
                        <blockquote class="equation">
                            output_rgb_component = &alpha; * input_rgb_component
                        </blockquote>
                        We can also obtain the brightened image through extrapolation.
                    </p>

                    <ul class="flex-container">
                        <li class="flex-item-item-5">
                            <div class="flex-item-item-5-img-container">
                                <img class="img-responsive" src="img/p1/brightness_0.bmp" alt="">
                            </div>
                            <span class="flex-item-text">0.0 <br> Black Image</span>
                        </li>
                        <li class="flex-item-item-5">
                            <div class="flex-item-item-5-img-container">
                                <img class="img-responsive" src="img/p1/brightness_0.5.bmp" alt="">
                            </div>
                            <span class="flex-item-text">0.5</span>
                        </li>
                        <li class="flex-item-item-5">
                            <div class="flex-item-item-5-img-container">
                                <img class="img-responsive" src="img/p1/brightness_1.bmp" alt="">
                            </div>
                            <span class="flex-item-text">1.0 <br> Input Image</span>
                        </li>
                        <li class="flex-item-item-5">
                            <div class="flex-item-item-5-img-container">
                                <img class="img-responsive" src="img/p1/brightness_1.5.bmp" alt="">
                            </div>
                            <span class="flex-item-text">1.5</span>
                        </li>
                        <li class="flex-item-item-5">
                            <div class="flex-item-item-5-img-container">
                                <img class="img-responsive" src="img/p1/brightness_2.bmp" alt="">
                            </div>
                            <span class="flex-item-text">2.0</span>
                        </li>
                    </ul>

                    <blockquote> Example Usage: 
                        <br>
                        <code>
                            $ ./image -brightness 1.5 &lt;input.bmp &gt;.out.bmp
                        </code>
                    </blockquote>








                    <h2 class="section-heading">Changing Contrast</h2>
                    <p>
                        Contrast is the difference in luminance that makes an object distinguishable. It can be controlled by interpolating and extrapolating between a constant grey image and the current image just like how we control brightness with a contract factor &alpha;. Interpolation reduces contrast and extrapolation boosts the contrast. The grey image is obtained by calculating the average image luminance and assign each grey pixel’s rgb components to the same average image luminance. Note that when a pixel’s rgb components are of the same value, it is on the grayscale. Here is one way to calculate pixel luminance (<a href ="http://www.itu.int/rec/R-REC-BT.601">http://www.itu.int/rec/R-REC-BT.601</a>): 
                        <blockquote class="equation">
                            pixel_luminance = (0.299 * R + 0.587 * G + 0.114 * B)
                        </blockquote>
                    </p>
                    <p>
                        Then apply interpolation on all rgb component for each pixel in the image as follows:
                        <blockquote class="equation">
                            output_rgb_component = (1 - &alpha;) * average_pixel_luminance + &alpha; * input_rgb_component
                        </blockquote>
                        A contrast factor of 0 produces a grey image with no contrast, 1 gives the original image, between 0 and 1 loses contrast, greater than 1 increases contrast, and less than 0 inverts the image. 
                    </p>
                    <ul class="flex-container">
                        <li class="flex-item-item-5">
                            <div class="flex-item-item-5-img-container">
                                <img class="img-responsive" src="img/p1/contrast_-1.bmp" alt="">
                            </div>
                            <span class="flex-item-text">-1.0</span>
                        </li>
                        <li class="flex-item-item-5">
                            <div class="flex-item-item-5-img-container">
                                <img class="img-responsive" src="img/p1/contrast_0.bmp" alt="">
                            </div>
                            <span class="flex-item-text">0.0 <br> Grey Image </span>
                        </li>
                        <li class="flex-item-item-5">
                            <div class="flex-item-item-5-img-container">
                                <img class="img-responsive" src="img/p1/contrast_0.5.bmp" alt="">
                            </div>
                            <span class="flex-item-text">0.5</span>
                        </li>
                        <li class="flex-item-item-5">
                            <div class="flex-item-item-5-img-container">
                                <img class="img-responsive" src="img/p1/contrast_1.bmp" alt="">
                            </div>
                            <span class="flex-item-text">1.0 <br> Input Image</span>
                        </li>
                        <li class="flex-item-item-5">
                            <div class="flex-item-item-5-img-container">
                                <img class="img-responsive" src="img/p1/contrast_2.bmp" alt="">
                            </div>
                            <span class="flex-item-text">2.0</span>
                        </li>
                    </ul>
                    <blockquote> Example Usage: 
                        <br>
                        <code>
                            $ ./image -contrast 1.5 &lt;input.bmp &gt;.out.bmp
                        </code>
                    </blockquote>





                    <h2 class="section-heading">Changing Saturation</h2>
                    <p>
                        Saturation refers to the perceived intensity of a specific color. It is the purity of the color and represents the amount of grey in proportion to the hue. To control the saturation of an image, pixel components must move towards or away from the pixel's luminance value. In other words, we interpolate between the grayscale version of the input image and the input image using the saturation factor &alpha;. The grayscale image is obtained by calculating a unique luminance per pixel using the same pixel luminance calculation discussed in the above section. Then apply the same interpolation technique as follows:
                        <blockquote class="equation">
                            output_rgb_component = (1 - &alpha;) * current_pixel_luminance + &alpha; * input_rgb_component
                        </blockquote>
                        When &alpha; is 0, we obtain the grayscale version of the image; when &alpha; is 1, we obtain the original input image. So when &alpha; is between 0 and 1, it makes the image grayer, reducing the saturation of the colors. For &alpha; bigger than 1, we extrapolate increasing saturation. As for negative values, the hues or colors of the input image is inverted, like a photographic negative.  
                    </p>
                    <ul class="flex-container">
                        <li class="flex-item-item-5">
                            <div class="flex-item-item-5-img-container">
                                <img class="img-responsive" src="img/p1/saturation_-1.bmp" alt="">
                            </div>
                            <span class="flex-item-text">-1.0</span>
                        </li>
                        <li class="flex-item-item-5">
                            <div class="flex-item-item-5-img-container">
                                <img class="img-responsive" src="img/p1/saturation_0.bmp" alt="">
                            </div>
                            <span class="flex-item-text">0.0 <br> Greyscale Image </span>
                        </li>
                        <li class="flex-item-item-5">
                            <div class="flex-item-item-5-img-container">
                                <img class="img-responsive" src="img/p1/saturation_0.5.bmp" alt="">
                            </div>
                            <span class="flex-item-text">0.5</span>
                        </li>
                        <li class="flex-item-item-5">
                            <div class="flex-item-item-5-img-container">
                                <img class="img-responsive" src="img/p1/saturation_1.bmp" alt="">
                            </div>
                            <span class="flex-item-text">1.0 <br> Input Image</span>
                        </li>
                        <li class="flex-item-item-5">
                            <div class="flex-item-item-5-img-container">
                                <img class="img-responsive" src="img/p1/saturation_2.bmp" alt="">
                            </div>
                            <span class="flex-item-text">2.0</span>
                        </li>
                    </ul>
                    <blockquote> Example Usage: 
                        <br>
                        <code>
                            $ ./image -saturation 1.5 &lt;input.bmp &gt;.out.bmp
                        </code>
                    </blockquote>






                    <h2 class="section-heading">Changing Gamma</h2>
                    <p>
                        Some images are not corrected for the nonlinear relationship between pixel value and displayed intensity for a color monitor. This nonlinear relationship can be described by a function raised to the power of gamma (&gamma;):
                        <blockquote class="equation">
                            displayed_intensity = rgb_component <sup>&gamma;</sup>
                        </blockquote>
                    </p>
                    <p>
                        Gamma correction corrects this by applying the inverse of this relationship to pixel values for all pixels in an image. Normally, input RGB component and output RGB component are in the range of 0 – 1; if the input RGB component is in the range of 0 - 255, we divide that component by 255 to normalize it:
                        <blockquote class="equation">
	                        normalized_input_rgb_component = input_rgb_component / 255
                            <br>
                            normalized_output_rgb_component = normalized_input_rgb_component <sup>(1.0 / &gamma;)</sup>
                            <br>
                            output_rgb_component = normalized_output_rgb_component * 255
                            <br>
                        </blockquote>
                        When &gamma; is 1, the output image is unchanged, &gamma; greater than 1 brighten it, and lower values darken it. Note that &gamma; should be positive. If &gamma; is 0, the output is a black image; if &gamma; is smaller than 0, no processing is done and the output is the input image.
                    </p>
                    <ul class="flex-container">
                        <li class="flex-item-item-5">
                            <div class="flex-item-item-5-img-container">
                                <img class="img-responsive" src="img/p1/gamma_0.bmp" alt="">
                            </div>
                            <span class="flex-item-text">&gamma; = 0.0 </span>
                        </li>
                        <li class="flex-item-item-5">
                            <div class="flex-item-item-5-img-container">
                                <img class="img-responsive" src="img/p1/gamma_0.5.bmp" alt="">
                            </div>
                            <span class="flex-item-text">0.5</span>
                        </li>
                        <li class="flex-item-item-5">
                            <div class="flex-item-item-5-img-container">
                                <img class="img-responsive" src="img/p1/flower.bmp" alt="">
                            </div>
                            <span class="flex-item-text">1.0 <br> Input Image</span>
                        </li>
                        <li class="flex-item-item-5">
                            <div class="flex-item-item-5-img-container">
                                <img class="img-responsive" src="img/p1/gamma_2.bmp" alt="">
                            </div>
                            <span class="flex-item-text">2.0</span>
                        </li>
                        <li class="flex-item-item-5">
                            <div class="flex-item-item-5-img-container">
                                <img class="img-responsive" src="img/p1/gamma_8.bmp" alt="">
                            </div>
                            <span class="flex-item-text">8.0</span>
                        </li>
                    </ul>
                    <blockquote> Example Usage: 
                        <br>
                        <code>
                            $ ./image -gamma 2.0 &lt;input.bmp &gt;.out.bmp
                        </code>
                    </blockquote>






                    <h2 class="section-heading">Cropping Images</h2>
                    <p>This allows one to crop the image, for instance to focus on a mandrill’s eye or nose as shown in the cropped picture below. The algorithm works by copying pixels at appropriate positions based on the offset x and y from a contiguous 1d array in the original image to a new image with newly specified width and height. We assume that x ranges from 0 to width-1 from left to right and y from 0 to height-1 from top to bottom. w and h are the size of the cropped image.</p>

                    <ul class="flex-container">
                        <li class="flex-item-item-4">
                            <div class="flex-item-item-4-img-container">
                                <img class="img-responsive" src="img/p1/mandrill.png" alt="">
                            </div>
                            <span class="flex-item-text">Original Image (512 x 512)</span>
                        </li>
                        <li class="flex-item-item-4">
                            <div class="flex-item-item-4-img-container">
                                <img class="img-responsive" src="img/p1/mandrill.png" alt="">
                            </div>
                            <span class="flex-item-text">Cropped Image: x=0, y=0, w=512, h=512</span>
                        </li>
                        <li class="flex-item-item-4">
                            <div class="flex-item-item-4-img-container">
                                <img class="img-responsive" src="img/p1/crop_mandrill_eye.png" alt="">
                            </div>
                            <span class="flex-item-text">Cropped Image: x=120, y=35, w=100, h=60</span>
                        </li>
                        <li class="flex-item-item-4">
                            <div class="flex-item-item-4-img-container">
                                <img class="img-responsive" src="img/p1/crop_mandrill_nose.png" alt="">
                            </div>
                            <span class="flex-item-text">Cropped Image: x=160, y=80, w=180, h=370</span>
                        </li>
                    </ul>

                    <p>
                        Below shows how we handle some interesting edge cases: 
                        <ul>
                            <li>
                                Case 1: If any of x, y, w, or h are negative, the output is an empty image. 
                            </li>
                            <li>
                                Case 2: If cropped image dimension exceeds original image bounds, that is if cropping parameter w, h larger than the original image height and width. Then the cropped image will only contain the captured portion of the original image, i.e. cropped_image_max_height = original_image_height - y 
                            </li>
                            <li>
                                Case 3: If x or y exceeds original image bounds then the output is an empty image
                            </li>
                            <li>
                                Case 4: If w or h are 0 then the output is an empty image
                            </li>
                        </ul>
                    </p>

                    <ul class="flex-container">
                        <li class="flex-item-item-4">
                            <div class="flex-item-item-4-img-container">
                                <img class="img-responsive" src="img/p1/crop_img_exceed_bonds.png" alt="">
                            </div>
                            <span class="flex-item-text">Case 2: x = 150, y = 50, w=15000, h=100</span>
                        </li>
                    </ul>

                    <blockquote> Example Usage: 
                        <br>
                        <code>
                            $ ./image -crop 150 50 100 100 &lt;input.bmp &gt;.out.bmp
                        </code>
                    </blockquote>





                    
                    <h2 class="section-heading">Quantization and Dithering</h2>
                    <p>
                        Dithering is used to create the illusion of "color depth" in images with a limited color palette using color quantization and reducing quantization errors. For example, when dithering an image of 8-bit color to 1-bit color, the colors that are available in the 8-bit color palette are approximated by a diffusion of colored pixels from the available 1-bit color palette. We have implemeted various techniques for dithering images with a small number of bits (1-8 bit) that we'll discuss below.
                    </p>
                    <h2 class="section-heading">Quantize</h2>
                    <p>
                        Color quantization is a process that reduces the number of distinct colors used in an image. To quantizes the image we use nbits per color channel. We first need to define a map between the input [0 - 255] and the output [0 - (2<sup>nbits</sup> - 1)]. Note that we only support nbits between 1 and 8 in our implementation. A simple way of doing this is to first convert all values into floating point to lie between 0 and 1 (by dividing the input by 256). Then, select the quantum using
                        <blockquote class="equation">
                            q = floor(p / 256.0f * b)
                        </blockquote>
                    </p>
                    <p>
                        where q is the appropriate quantum, p is the original pixel value in the range from 0 to 1, and b is the number of bins or quanta and is calculated using
                        <blockquote class="equation">
                            b = 2<sup>nbits</sup>
                        </blockquote>
                    </p>
                    <p>
                        These values must then be mapped back into the 0 - 255 range, which can be done by computing the final color
                        <blockquote class="equation">
	                        c<sub>f</sub> = floor(255 * q / (b - 1))
                        </blockquote>
                    </p>
                    <p>
                        Note that a fast way for calculate b = 2<sup>nbits</sup> is to use bit shifting in c++
                        <blockquote class="equation">
	                        b = 1 << nbits
                        </blockquote>
                    </p>
                    <p>
                        The problem with quantization is that it introduces a clear contouring for lower numbers of bits. To prevent this from happening we will need to handle quantization errors better. Dithering is such a process that can distribute errors among pixels to obtain better results. We have implemented two dithering algorithms here: Random Dither and Floyd-Steinberg Dither.
                    </p>
                    <h2 class="section-heading">Random Dither</h2>
                    <p>
                        Random Dither adds some noise before quantizing. The noise helps to break up the contouring. Perceptually, noise is found to be preferable since human eyes are more tolerant of high-frequency noise than contours or aliasing. In addition to the quantization process above, we add noise in the range from [-.5 ... +.5], which is generated using the random function.
                        <blockquote class="equation">
                            q = floor(p / 256.0f * noise)
                        </blockquote>
                    </p>
                    <p>
                        The algorithm achieves dithering using error diffusion, meaning it pushes (adds) the residual quantization error of a pixel onto its neighboring pixels, to be dealt with later. It spreads the debt out according to the distribution (shown as a map of the neighboring pixels):
                        <img class="img-responsive" style="margin: 35px;" src="img/p1/error_diffusion.png" alt="">
                        <blockquote class="equation">
                            stuff
                        </blockquote>
                    </p>



                    <ul class="flex-container">
                        <li class="flex-item-item-5">
                            <div class="flex-item-item-5-img-container">
                                <img class="img-responsive" src="img/p1/gamma_0.bmp" alt="">
                            </div>
                            <span class="flex-item-text">&gamma; = 0.0 </span>
                        </li>
                        <li class="flex-item-item-5">
                            <div class="flex-item-item-5-img-container">
                                <img class="img-responsive" src="img/p1/gamma_0.5.bmp" alt="">
                            </div>
                            <span class="flex-item-text">0.5</span>
                        </li>
                        <li class="flex-item-item-5">
                            <div class="flex-item-item-5-img-container">
                                <img class="img-responsive" src="img/p1/flower.bmp" alt="">
                            </div>
                            <span class="flex-item-text">1.0 <br> Input Image</span>
                        </li>
                        <li class="flex-item-item-5">
                            <div class="flex-item-item-5-img-container">
                                <img class="img-responsive" src="img/p1/gamma_2.bmp" alt="">
                            </div>
                            <span class="flex-item-text">2.0</span>
                        </li>
                        <li class="flex-item-item-5">
                            <div class="flex-item-item-5-img-container">
                                <img class="img-responsive" src="img/p1/gamma_8.bmp" alt="">
                            </div>
                            <span class="flex-item-text">8.0</span>
                        </li>
                    </ul>
                    <blockquote> Example Usage: 
                        <br>
                        <code>
                            $ ./image -quantize 2 &lt;input.bmp &gt;.out.bmp
                        </code>
                    </blockquote>






                    

                </div>
            </div>
        </div>
    </article>

    <hr>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    <!--<ul class="list-inline text-center">
                        <li>
                            <a href="#">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                        <li>
                            <a href="#">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-facebook fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                        <li>
                            <a href="#">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    </ul>-->
                    <p class="copyright text-muted">Copyright &copy; 2017</p>
                </div>
            </div>
        </div>
    </footer>

    <!-- jQuery -->
    <script src="vendor/jquery/jquery.min.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="vendor/bootstrap/js/bootstrap.min.js"></script>

    <!-- Contact Form JavaScript -->
    <script src="js/jqBootstrapValidation.js"></script>
    <script src="js/contact_me.js"></script>

    <!-- Theme JavaScript -->
    <script src="js/clean-blog.min.js"></script>

</body>

</html>
